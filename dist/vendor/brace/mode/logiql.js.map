{"version":3,"sources":["webpack:///vendor/brace/mode/logiql.js","webpack:///../node_modules/brace/mode/logiql.js"],"names":["flklrJsonp","85","module","exports","ace","define","acequire","oop","TextHighlightRules","LogiQLHighlightRules","this","$rules","start","token","regex","push","next","defaultToken","comment","include","normalizeRules","inherits","BaseFoldMode","FoldMode","Range","getFoldWidgetRange","session","foldStyle","row","range","indentationBlock","re","line","getLine","startLevel","search","startColumn","length","maxRow","getLength","startRow","endRow","level","endColumn","getFoldWidget","indent","prev","prevIndent","nextIndent","foldWidgets","call","prototype","MatchingBraceOutdent","checkOutdent","input","test","autoOutdent","doc","match","column","openBracePos","findMatchingBracket","$getIndent","replace","TextMode","Mode","TokenIterator","CstyleBehaviour","HighlightRules","foldingRules","$outdent","$behaviour","lineCommentStart","blockComment","end","getNextLineIndent","state","tab","tokenizedLine","getTokenizer","getLineTokens","tokens","type","prevLine","lastIndexOf","startRange","getMatching","undefined","selection","lead","tok","startToken","getTokenAt","it","step","stepForward","stepBackward","col","getCurrentTokenColumn","getCurrentTokenRow","value","$id"],"mappings":"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","file":"vendor/brace/mode/logiql.js","sourcesContent":["flklrJsonp([120],{\n\n/***/ 85:\n/***/ (function(module, exports) {\n\nace.define(\"ace/mode/logiql_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text_highlight_rules\"], function(acequire, exports, module) {\n\"use strict\";\n\nvar oop = acequire(\"../lib/oop\");\nvar TextHighlightRules = acequire(\"./text_highlight_rules\").TextHighlightRules;\n\nvar LogiQLHighlightRules = function() {\n\n    this.$rules = { start: \n       [ { token: 'comment.block',\n           regex: '/\\\\*',\n           push: \n            [ { token: 'comment.block', regex: '\\\\*/', next: 'pop' },\n              { defaultToken: 'comment.block' } ]\n            },\n         { token: 'comment.single',\n           regex: '//.*'\n            },\n         { token: 'constant.numeric',\n           regex: '\\\\d+(?:\\\\.\\\\d+)?(?:[eE][+-]?\\\\d+)?[fd]?'\n            },\n         { token: 'string',\n           regex: '\"',\n           push: \n            [ { token: 'string', regex: '\"', next: 'pop' },\n              { defaultToken: 'string' } ]\n            },\n         { token: 'constant.language',\n           regex: '\\\\b(true|false)\\\\b'\n            },\n         { token: 'entity.name.type.logicblox',\n           regex: '`[a-zA-Z_:]+(\\\\d|\\\\a)*\\\\b'\n            },\n         { token: 'keyword.start', regex: '->',  comment: 'Constraint' },\n         { token: 'keyword.start', regex: '-->', comment: 'Level 1 Constraint'},\n         { token: 'keyword.start', regex: '<-',  comment: 'Rule' },\n         { token: 'keyword.start', regex: '<--', comment: 'Level 1 Rule' },\n         { token: 'keyword.end',   regex: '\\\\.', comment: 'Terminator' },\n         { token: 'keyword.other', regex: '!',   comment: 'Negation' },\n         { token: 'keyword.other', regex: ',',   comment: 'Conjunction' },\n         { token: 'keyword.other', regex: ';',   comment: 'Disjunction' },\n         { token: 'keyword.operator', regex: '<=|>=|!=|<|>', comment: 'Equality'},\n         { token: 'keyword.other', regex: '@', comment: 'Equality' },\n         { token: 'keyword.operator', regex: '\\\\+|-|\\\\*|/', comment: 'Arithmetic operations'},\n         { token: 'keyword', regex: '::', comment: 'Colon colon' },\n         { token: 'support.function',\n           regex: '\\\\b(agg\\\\s*<<)',\n           push: \n            [ { include: '$self' },\n              { token: 'support.function',\n                regex: '>>',\n                next: 'pop' } ]\n            },\n         { token: 'storage.modifier',\n           regex: '\\\\b(lang:[\\\\w:]*)'\n            },\n         { token: [ 'storage.type', 'text' ],\n           regex: '(export|sealed|clauses|block|alias|alias_all)(\\\\s*\\\\()(?=`)'\n            },\n         { token: 'entity.name',\n           regex: '[a-zA-Z_][a-zA-Z_0-9:]*(@prev|@init|@final)?(?=(\\\\(|\\\\[))'\n            },\n         { token: 'variable.parameter',\n           regex: '([a-zA-Z][a-zA-Z_0-9]*|_)\\\\s*(?=(,|\\\\.|<-|->|\\\\)|\\\\]|=))'\n            } ] }\n    \n    this.normalizeRules();\n};\n\noop.inherits(LogiQLHighlightRules, TextHighlightRules);\n\nexports.LogiQLHighlightRules = LogiQLHighlightRules;\n});\n\nace.define(\"ace/mode/folding/coffee\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/folding/fold_mode\",\"ace/range\"], function(acequire, exports, module) {\n\"use strict\";\n\nvar oop = acequire(\"../../lib/oop\");\nvar BaseFoldMode = acequire(\"./fold_mode\").FoldMode;\nvar Range = acequire(\"../../range\").Range;\n\nvar FoldMode = exports.FoldMode = function() {};\noop.inherits(FoldMode, BaseFoldMode);\n\n(function() {\n\n    this.getFoldWidgetRange = function(session, foldStyle, row) {\n        var range = this.indentationBlock(session, row);\n        if (range)\n            return range;\n\n        var re = /\\S/;\n        var line = session.getLine(row);\n        var startLevel = line.search(re);\n        if (startLevel == -1 || line[startLevel] != \"#\")\n            return;\n\n        var startColumn = line.length;\n        var maxRow = session.getLength();\n        var startRow = row;\n        var endRow = row;\n\n        while (++row < maxRow) {\n            line = session.getLine(row);\n            var level = line.search(re);\n\n            if (level == -1)\n                continue;\n\n            if (line[level] != \"#\")\n                break;\n\n            endRow = row;\n        }\n\n        if (endRow > startRow) {\n            var endColumn = session.getLine(endRow).length;\n            return new Range(startRow, startColumn, endRow, endColumn);\n        }\n    };\n    this.getFoldWidget = function(session, foldStyle, row) {\n        var line = session.getLine(row);\n        var indent = line.search(/\\S/);\n        var next = session.getLine(row + 1);\n        var prev = session.getLine(row - 1);\n        var prevIndent = prev.search(/\\S/);\n        var nextIndent = next.search(/\\S/);\n\n        if (indent == -1) {\n            session.foldWidgets[row - 1] = prevIndent!= -1 && prevIndent < nextIndent ? \"start\" : \"\";\n            return \"\";\n        }\n        if (prevIndent == -1) {\n            if (indent == nextIndent && line[indent] == \"#\" && next[indent] == \"#\") {\n                session.foldWidgets[row - 1] = \"\";\n                session.foldWidgets[row + 1] = \"\";\n                return \"start\";\n            }\n        } else if (prevIndent == indent && line[indent] == \"#\" && prev[indent] == \"#\") {\n            if (session.getLine(row - 2).search(/\\S/) == -1) {\n                session.foldWidgets[row - 1] = \"start\";\n                session.foldWidgets[row + 1] = \"\";\n                return \"\";\n            }\n        }\n\n        if (prevIndent!= -1 && prevIndent < indent)\n            session.foldWidgets[row - 1] = \"start\";\n        else\n            session.foldWidgets[row - 1] = \"\";\n\n        if (indent < nextIndent)\n            return \"start\";\n        else\n            return \"\";\n    };\n\n}).call(FoldMode.prototype);\n\n});\n\nace.define(\"ace/mode/matching_brace_outdent\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(acequire, exports, module) {\n\"use strict\";\n\nvar Range = acequire(\"../range\").Range;\n\nvar MatchingBraceOutdent = function() {};\n\n(function() {\n\n    this.checkOutdent = function(line, input) {\n        if (! /^\\s+$/.test(line))\n            return false;\n\n        return /^\\s*\\}/.test(input);\n    };\n\n    this.autoOutdent = function(doc, row) {\n        var line = doc.getLine(row);\n        var match = line.match(/^(\\s*\\})/);\n\n        if (!match) return 0;\n\n        var column = match[1].length;\n        var openBracePos = doc.findMatchingBracket({row: row, column: column});\n\n        if (!openBracePos || openBracePos.row == row) return 0;\n\n        var indent = this.$getIndent(doc.getLine(openBracePos.row));\n        doc.replace(new Range(row, 0, row, column-1), indent);\n    };\n\n    this.$getIndent = function(line) {\n        return line.match(/^\\s*/)[0];\n    };\n\n}).call(MatchingBraceOutdent.prototype);\n\nexports.MatchingBraceOutdent = MatchingBraceOutdent;\n});\n\nace.define(\"ace/mode/logiql\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text\",\"ace/mode/logiql_highlight_rules\",\"ace/mode/folding/coffee\",\"ace/token_iterator\",\"ace/range\",\"ace/mode/behaviour/cstyle\",\"ace/mode/matching_brace_outdent\"], function(acequire, exports, module) {\n\"use strict\";\n\nvar oop = acequire(\"../lib/oop\");\nvar TextMode = acequire(\"./text\").Mode;\nvar LogiQLHighlightRules = acequire(\"./logiql_highlight_rules\").LogiQLHighlightRules;\nvar FoldMode = acequire(\"./folding/coffee\").FoldMode;\nvar TokenIterator = acequire(\"../token_iterator\").TokenIterator;\nvar Range = acequire(\"../range\").Range;\nvar CstyleBehaviour = acequire(\"./behaviour/cstyle\").CstyleBehaviour;\nvar MatchingBraceOutdent = acequire(\"./matching_brace_outdent\").MatchingBraceOutdent;\n\nvar Mode = function() {\n    this.HighlightRules = LogiQLHighlightRules;\n    this.foldingRules = new FoldMode();\n    this.$outdent = new MatchingBraceOutdent();\n    this.$behaviour = new CstyleBehaviour();\n};\noop.inherits(Mode, TextMode);\n\n(function() {\n    this.lineCommentStart = \"//\";\n    this.blockComment = {start: \"/*\", end: \"*/\"};\n\n    this.getNextLineIndent = function(state, line, tab) {\n        var indent = this.$getIndent(line);\n\n        var tokenizedLine = this.getTokenizer().getLineTokens(line, state);\n        var tokens = tokenizedLine.tokens;\n        var endState = tokenizedLine.state;\n        if (/comment|string/.test(endState))  \n            return indent;\n        if (tokens.length && tokens[tokens.length - 1].type == \"comment.single\")\n            return indent;\n\n        var match = line.match();\n        if (/(-->|<--|<-|->|{)\\s*$/.test(line))\n            indent += tab;\n        return indent;\n    };\n\n    this.checkOutdent = function(state, line, input) {\n        if (this.$outdent.checkOutdent(line, input))\n            return true;\n\n        if (input !== \"\\n\" && input !== \"\\r\\n\")\n            return false;\n            \n        if (!/^\\s+/.test(line))\n            return false;\n\n        return true;\n    };\n\n    this.autoOutdent = function(state, doc, row) {\n        if (this.$outdent.autoOutdent(doc, row))\n            return;\n        var prevLine = doc.getLine(row);\n        var match = prevLine.match(/^\\s+/);\n        var column = prevLine.lastIndexOf(\".\") + 1;\n        if (!match || !row || !column) return 0;\n\n        var line = doc.getLine(row + 1);\n        var startRange = this.getMatching(doc, {row: row, column: column});\n        if (!startRange || startRange.start.row == row) return 0;\n\n        column = match[0].length;\n        var indent = this.$getIndent(doc.getLine(startRange.start.row));\n        doc.replace(new Range(row + 1, 0, row + 1, column), indent);\n    };\n\n    this.getMatching = function(session, row, column) {\n        if (row == undefined)\n            row = session.selection.lead\n        if (typeof row == \"object\") {\n            column = row.column;\n            row = row.row;\n        }\n\n        var startToken = session.getTokenAt(row, column);\n        var KW_START = \"keyword.start\", KW_END = \"keyword.end\";\n        var tok;\n        if (!startToken)\n            return;\n        if (startToken.type == KW_START) {\n            var it = new TokenIterator(session, row, column);\n            it.step = it.stepForward;\n        } else if (startToken.type == KW_END) {\n            var it = new TokenIterator(session, row, column);\n            it.step = it.stepBackward;\n        } else\n            return;\n\n        while (tok = it.step()) {\n            if (tok.type == KW_START || tok.type == KW_END)\n                break;\n        }\n        if (!tok || tok.type == startToken.type)\n            return;\n\n        var col = it.getCurrentTokenColumn();\n        var row = it.getCurrentTokenRow();\n        return new Range(row, col, row, col + tok.value.length);\n    };\n    this.$id = \"ace/mode/logiql\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n});\n\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// vendor/brace/mode/logiql.js","ace.define(\"ace/mode/logiql_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text_highlight_rules\"], function(acequire, exports, module) {\n\"use strict\";\n\nvar oop = acequire(\"../lib/oop\");\nvar TextHighlightRules = acequire(\"./text_highlight_rules\").TextHighlightRules;\n\nvar LogiQLHighlightRules = function() {\n\n    this.$rules = { start: \n       [ { token: 'comment.block',\n           regex: '/\\\\*',\n           push: \n            [ { token: 'comment.block', regex: '\\\\*/', next: 'pop' },\n              { defaultToken: 'comment.block' } ]\n            },\n         { token: 'comment.single',\n           regex: '//.*'\n            },\n         { token: 'constant.numeric',\n           regex: '\\\\d+(?:\\\\.\\\\d+)?(?:[eE][+-]?\\\\d+)?[fd]?'\n            },\n         { token: 'string',\n           regex: '\"',\n           push: \n            [ { token: 'string', regex: '\"', next: 'pop' },\n              { defaultToken: 'string' } ]\n            },\n         { token: 'constant.language',\n           regex: '\\\\b(true|false)\\\\b'\n            },\n         { token: 'entity.name.type.logicblox',\n           regex: '`[a-zA-Z_:]+(\\\\d|\\\\a)*\\\\b'\n            },\n         { token: 'keyword.start', regex: '->',  comment: 'Constraint' },\n         { token: 'keyword.start', regex: '-->', comment: 'Level 1 Constraint'},\n         { token: 'keyword.start', regex: '<-',  comment: 'Rule' },\n         { token: 'keyword.start', regex: '<--', comment: 'Level 1 Rule' },\n         { token: 'keyword.end',   regex: '\\\\.', comment: 'Terminator' },\n         { token: 'keyword.other', regex: '!',   comment: 'Negation' },\n         { token: 'keyword.other', regex: ',',   comment: 'Conjunction' },\n         { token: 'keyword.other', regex: ';',   comment: 'Disjunction' },\n         { token: 'keyword.operator', regex: '<=|>=|!=|<|>', comment: 'Equality'},\n         { token: 'keyword.other', regex: '@', comment: 'Equality' },\n         { token: 'keyword.operator', regex: '\\\\+|-|\\\\*|/', comment: 'Arithmetic operations'},\n         { token: 'keyword', regex: '::', comment: 'Colon colon' },\n         { token: 'support.function',\n           regex: '\\\\b(agg\\\\s*<<)',\n           push: \n            [ { include: '$self' },\n              { token: 'support.function',\n                regex: '>>',\n                next: 'pop' } ]\n            },\n         { token: 'storage.modifier',\n           regex: '\\\\b(lang:[\\\\w:]*)'\n            },\n         { token: [ 'storage.type', 'text' ],\n           regex: '(export|sealed|clauses|block|alias|alias_all)(\\\\s*\\\\()(?=`)'\n            },\n         { token: 'entity.name',\n           regex: '[a-zA-Z_][a-zA-Z_0-9:]*(@prev|@init|@final)?(?=(\\\\(|\\\\[))'\n            },\n         { token: 'variable.parameter',\n           regex: '([a-zA-Z][a-zA-Z_0-9]*|_)\\\\s*(?=(,|\\\\.|<-|->|\\\\)|\\\\]|=))'\n            } ] }\n    \n    this.normalizeRules();\n};\n\noop.inherits(LogiQLHighlightRules, TextHighlightRules);\n\nexports.LogiQLHighlightRules = LogiQLHighlightRules;\n});\n\nace.define(\"ace/mode/folding/coffee\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/folding/fold_mode\",\"ace/range\"], function(acequire, exports, module) {\n\"use strict\";\n\nvar oop = acequire(\"../../lib/oop\");\nvar BaseFoldMode = acequire(\"./fold_mode\").FoldMode;\nvar Range = acequire(\"../../range\").Range;\n\nvar FoldMode = exports.FoldMode = function() {};\noop.inherits(FoldMode, BaseFoldMode);\n\n(function() {\n\n    this.getFoldWidgetRange = function(session, foldStyle, row) {\n        var range = this.indentationBlock(session, row);\n        if (range)\n            return range;\n\n        var re = /\\S/;\n        var line = session.getLine(row);\n        var startLevel = line.search(re);\n        if (startLevel == -1 || line[startLevel] != \"#\")\n            return;\n\n        var startColumn = line.length;\n        var maxRow = session.getLength();\n        var startRow = row;\n        var endRow = row;\n\n        while (++row < maxRow) {\n            line = session.getLine(row);\n            var level = line.search(re);\n\n            if (level == -1)\n                continue;\n\n            if (line[level] != \"#\")\n                break;\n\n            endRow = row;\n        }\n\n        if (endRow > startRow) {\n            var endColumn = session.getLine(endRow).length;\n            return new Range(startRow, startColumn, endRow, endColumn);\n        }\n    };\n    this.getFoldWidget = function(session, foldStyle, row) {\n        var line = session.getLine(row);\n        var indent = line.search(/\\S/);\n        var next = session.getLine(row + 1);\n        var prev = session.getLine(row - 1);\n        var prevIndent = prev.search(/\\S/);\n        var nextIndent = next.search(/\\S/);\n\n        if (indent == -1) {\n            session.foldWidgets[row - 1] = prevIndent!= -1 && prevIndent < nextIndent ? \"start\" : \"\";\n            return \"\";\n        }\n        if (prevIndent == -1) {\n            if (indent == nextIndent && line[indent] == \"#\" && next[indent] == \"#\") {\n                session.foldWidgets[row - 1] = \"\";\n                session.foldWidgets[row + 1] = \"\";\n                return \"start\";\n            }\n        } else if (prevIndent == indent && line[indent] == \"#\" && prev[indent] == \"#\") {\n            if (session.getLine(row - 2).search(/\\S/) == -1) {\n                session.foldWidgets[row - 1] = \"start\";\n                session.foldWidgets[row + 1] = \"\";\n                return \"\";\n            }\n        }\n\n        if (prevIndent!= -1 && prevIndent < indent)\n            session.foldWidgets[row - 1] = \"start\";\n        else\n            session.foldWidgets[row - 1] = \"\";\n\n        if (indent < nextIndent)\n            return \"start\";\n        else\n            return \"\";\n    };\n\n}).call(FoldMode.prototype);\n\n});\n\nace.define(\"ace/mode/matching_brace_outdent\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(acequire, exports, module) {\n\"use strict\";\n\nvar Range = acequire(\"../range\").Range;\n\nvar MatchingBraceOutdent = function() {};\n\n(function() {\n\n    this.checkOutdent = function(line, input) {\n        if (! /^\\s+$/.test(line))\n            return false;\n\n        return /^\\s*\\}/.test(input);\n    };\n\n    this.autoOutdent = function(doc, row) {\n        var line = doc.getLine(row);\n        var match = line.match(/^(\\s*\\})/);\n\n        if (!match) return 0;\n\n        var column = match[1].length;\n        var openBracePos = doc.findMatchingBracket({row: row, column: column});\n\n        if (!openBracePos || openBracePos.row == row) return 0;\n\n        var indent = this.$getIndent(doc.getLine(openBracePos.row));\n        doc.replace(new Range(row, 0, row, column-1), indent);\n    };\n\n    this.$getIndent = function(line) {\n        return line.match(/^\\s*/)[0];\n    };\n\n}).call(MatchingBraceOutdent.prototype);\n\nexports.MatchingBraceOutdent = MatchingBraceOutdent;\n});\n\nace.define(\"ace/mode/logiql\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text\",\"ace/mode/logiql_highlight_rules\",\"ace/mode/folding/coffee\",\"ace/token_iterator\",\"ace/range\",\"ace/mode/behaviour/cstyle\",\"ace/mode/matching_brace_outdent\"], function(acequire, exports, module) {\n\"use strict\";\n\nvar oop = acequire(\"../lib/oop\");\nvar TextMode = acequire(\"./text\").Mode;\nvar LogiQLHighlightRules = acequire(\"./logiql_highlight_rules\").LogiQLHighlightRules;\nvar FoldMode = acequire(\"./folding/coffee\").FoldMode;\nvar TokenIterator = acequire(\"../token_iterator\").TokenIterator;\nvar Range = acequire(\"../range\").Range;\nvar CstyleBehaviour = acequire(\"./behaviour/cstyle\").CstyleBehaviour;\nvar MatchingBraceOutdent = acequire(\"./matching_brace_outdent\").MatchingBraceOutdent;\n\nvar Mode = function() {\n    this.HighlightRules = LogiQLHighlightRules;\n    this.foldingRules = new FoldMode();\n    this.$outdent = new MatchingBraceOutdent();\n    this.$behaviour = new CstyleBehaviour();\n};\noop.inherits(Mode, TextMode);\n\n(function() {\n    this.lineCommentStart = \"//\";\n    this.blockComment = {start: \"/*\", end: \"*/\"};\n\n    this.getNextLineIndent = function(state, line, tab) {\n        var indent = this.$getIndent(line);\n\n        var tokenizedLine = this.getTokenizer().getLineTokens(line, state);\n        var tokens = tokenizedLine.tokens;\n        var endState = tokenizedLine.state;\n        if (/comment|string/.test(endState))  \n            return indent;\n        if (tokens.length && tokens[tokens.length - 1].type == \"comment.single\")\n            return indent;\n\n        var match = line.match();\n        if (/(-->|<--|<-|->|{)\\s*$/.test(line))\n            indent += tab;\n        return indent;\n    };\n\n    this.checkOutdent = function(state, line, input) {\n        if (this.$outdent.checkOutdent(line, input))\n            return true;\n\n        if (input !== \"\\n\" && input !== \"\\r\\n\")\n            return false;\n            \n        if (!/^\\s+/.test(line))\n            return false;\n\n        return true;\n    };\n\n    this.autoOutdent = function(state, doc, row) {\n        if (this.$outdent.autoOutdent(doc, row))\n            return;\n        var prevLine = doc.getLine(row);\n        var match = prevLine.match(/^\\s+/);\n        var column = prevLine.lastIndexOf(\".\") + 1;\n        if (!match || !row || !column) return 0;\n\n        var line = doc.getLine(row + 1);\n        var startRange = this.getMatching(doc, {row: row, column: column});\n        if (!startRange || startRange.start.row == row) return 0;\n\n        column = match[0].length;\n        var indent = this.$getIndent(doc.getLine(startRange.start.row));\n        doc.replace(new Range(row + 1, 0, row + 1, column), indent);\n    };\n\n    this.getMatching = function(session, row, column) {\n        if (row == undefined)\n            row = session.selection.lead\n        if (typeof row == \"object\") {\n            column = row.column;\n            row = row.row;\n        }\n\n        var startToken = session.getTokenAt(row, column);\n        var KW_START = \"keyword.start\", KW_END = \"keyword.end\";\n        var tok;\n        if (!startToken)\n            return;\n        if (startToken.type == KW_START) {\n            var it = new TokenIterator(session, row, column);\n            it.step = it.stepForward;\n        } else if (startToken.type == KW_END) {\n            var it = new TokenIterator(session, row, column);\n            it.step = it.stepBackward;\n        } else\n            return;\n\n        while (tok = it.step()) {\n            if (tok.type == KW_START || tok.type == KW_END)\n                break;\n        }\n        if (!tok || tok.type == startToken.type)\n            return;\n\n        var col = it.getCurrentTokenColumn();\n        var row = it.getCurrentTokenRow();\n        return new Range(row, col, row, col + tok.value.length);\n    };\n    this.$id = \"ace/mode/logiql\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../node_modules/brace/mode/logiql.js\n// module id = 85\n// module chunks = 120"],"sourceRoot":""}