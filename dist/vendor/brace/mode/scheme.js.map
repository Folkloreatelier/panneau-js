{"version":3,"sources":["webpack:///vendor/brace/mode/scheme.js","webpack:///../node_modules/brace/mode/scheme.js"],"names":["flklrJsonp","126","module","exports","ace","define","acequire","oop","TextHighlightRules","SchemeHighlightRules","keywordMapper","this","createKeywordMapper","keyword.control","keyword.operator","constant.language","support.function","$rules","start","token","regex","next","qqstring","merge","inherits","Range","MatchingParensOutdent","checkOutdent","line","input","test","autoOutdent","doc","row","getLine","match","column","length","openBracePos","findMatchingBracket","indent","$getIndent","replace","call","prototype","TextMode","Mode","HighlightRules","$outdent","$behaviour","$defaultBehaviour","lineCommentStart","minorIndentFunctions","$toIndent","str","split","map","ch","exec","join","$calculateIndent","tab","isParen","baseIndent","delta","i","substring","iBefore","fn","indexOf","undefined","getNextLineIndent","state","$id"],"mappings":"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","file":"vendor/brace/mode/scheme.js","sourcesContent":["flklrJsonp([86],{\n\n/***/ 126:\n/***/ (function(module, exports) {\n\nace.define(\"ace/mode/scheme_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text_highlight_rules\"], function(acequire, exports, module) {\n\"use strict\";\n\nvar oop = acequire(\"../lib/oop\");\nvar TextHighlightRules = acequire(\"./text_highlight_rules\").TextHighlightRules;\n\nvar SchemeHighlightRules = function() {\n    var keywordControl = \"case|do|let|loop|if|else|when\";\n    var keywordOperator = \"eq?|eqv?|equal?|and|or|not|null?\";\n    var constantLanguage = \"#t|#f\";\n    var supportFunctions = \"cons|car|cdr|cond|lambda|lambda*|syntax-rules|format|set!|quote|eval|append|list|list?|member?|load\";\n\n    var keywordMapper = this.createKeywordMapper({\n        \"keyword.control\": keywordControl,\n        \"keyword.operator\": keywordOperator,\n        \"constant.language\": constantLanguage,\n        \"support.function\": supportFunctions\n    }, \"identifier\", true);\n\n    this.$rules = \n        {\n    \"start\": [\n        {\n            token : \"comment\",\n            regex : \";.*$\"\n        },\n        {\n            \"token\": [\"storage.type.function-type.scheme\", \"text\", \"entity.name.function.scheme\"],\n            \"regex\": \"(?:\\\\b(?:(define|define-syntax|define-macro))\\\\b)(\\\\s+)((?:\\\\w|\\\\-|\\\\!|\\\\?)*)\"\n        },\n        {\n            \"token\": \"punctuation.definition.constant.character.scheme\",\n            \"regex\": \"#:\\\\S+\"\n        },\n        {\n            \"token\": [\"punctuation.definition.variable.scheme\", \"variable.other.global.scheme\", \"punctuation.definition.variable.scheme\"],\n            \"regex\": \"(\\\\*)(\\\\S*)(\\\\*)\"\n        },\n        {\n            \"token\" : \"constant.numeric\", // hex\n            \"regex\" : \"#[xXoObB][0-9a-fA-F]+\"\n        }, \n        {\n            \"token\" : \"constant.numeric\", // float\n            \"regex\" : \"[+-]?\\\\d+(?:(?:\\\\.\\\\d*)?(?:[eE][+-]?\\\\d+)?)?\"\n        },\n        {\n                \"token\" : keywordMapper,\n                \"regex\" : \"[a-zA-Z_#][a-zA-Z0-9_\\\\-\\\\?\\\\!\\\\*]*\"\n        },\n        {\n            \"token\" : \"string\",\n            \"regex\" : '\"(?=.)',\n            \"next\"  : \"qqstring\"\n        }\n    ],\n    \"qqstring\": [\n        {\n            \"token\": \"constant.character.escape.scheme\",\n            \"regex\": \"\\\\\\\\.\"\n        },\n        {\n            \"token\" : \"string\",\n            \"regex\" : '[^\"\\\\\\\\]+',\n            \"merge\" : true\n        }, {\n            \"token\" : \"string\",\n            \"regex\" : \"\\\\\\\\$\",\n            \"next\"  : \"qqstring\",\n            \"merge\" : true\n        }, {\n            \"token\" : \"string\",\n            \"regex\" : '\"|$',\n            \"next\"  : \"start\",\n            \"merge\" : true\n        }\n    ]\n}\n\n};\n\noop.inherits(SchemeHighlightRules, TextHighlightRules);\n\nexports.SchemeHighlightRules = SchemeHighlightRules;\n});\n\nace.define(\"ace/mode/matching_parens_outdent\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(acequire, exports, module) {\n\"use strict\";\n\nvar Range = acequire(\"../range\").Range;\n\nvar MatchingParensOutdent = function() {};\n\n(function() {\n\n    this.checkOutdent = function(line, input) {\n        if (! /^\\s+$/.test(line))\n            return false;\n\n        return /^\\s*\\)/.test(input);\n    };\n\n    this.autoOutdent = function(doc, row) {\n        var line = doc.getLine(row);\n        var match = line.match(/^(\\s*\\))/);\n\n        if (!match) return 0;\n\n        var column = match[1].length;\n        var openBracePos = doc.findMatchingBracket({row: row, column: column});\n\n        if (!openBracePos || openBracePos.row == row) return 0;\n\n        var indent = this.$getIndent(doc.getLine(openBracePos.row));\n        doc.replace(new Range(row, 0, row, column-1), indent);\n    };\n\n    this.$getIndent = function(line) {\n        var match = line.match(/^(\\s+)/);\n        if (match) {\n            return match[1];\n        }\n\n        return \"\";\n    };\n\n}).call(MatchingParensOutdent.prototype);\n\nexports.MatchingParensOutdent = MatchingParensOutdent;\n});\n\nace.define(\"ace/mode/scheme\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text\",\"ace/mode/scheme_highlight_rules\",\"ace/mode/matching_parens_outdent\"], function(acequire, exports, module) {\n\"use strict\";\n\nvar oop = acequire(\"../lib/oop\");\nvar TextMode = acequire(\"./text\").Mode;\nvar SchemeHighlightRules = acequire(\"./scheme_highlight_rules\").SchemeHighlightRules;\nvar MatchingParensOutdent = acequire(\"./matching_parens_outdent\").MatchingParensOutdent;\n\nvar Mode = function() {\n    this.HighlightRules = SchemeHighlightRules;\n\tthis.$outdent = new MatchingParensOutdent();\n    this.$behaviour = this.$defaultBehaviour;\n};\noop.inherits(Mode, TextMode);\n\n(function() {\n       \n    this.lineCommentStart = \";\";\n    this.minorIndentFunctions = [\"define\", \"lambda\", \"define-macro\", \"define-syntax\", \"syntax-rules\", \"define-record-type\", \"define-structure\"];\n\n    this.$toIndent = function(str) {\n        return str.split('').map(function(ch) {\n            if (/\\s/.exec(ch)) {\n                return ch;\n            } else {\n                return ' ';\n            }\n        }).join('');\n    };\n\n    this.$calculateIndent = function(line, tab) {\n        var baseIndent = this.$getIndent(line);\n        var delta = 0;\n        var isParen, ch;\n        for (var i = line.length - 1; i >= 0; i--) {\n            ch = line[i];\n            if (ch === '(') {\n                delta--;\n                isParen = true;\n            } else if (ch === '(' || ch === '[' || ch === '{') {\n                delta--;\n                isParen = false;\n            } else if (ch === ')' || ch === ']' || ch === '}') {\n                delta++;\n            }\n            if (delta < 0) {\n                break;\n            }\n        }\n        if (delta < 0 && isParen) {\n            i += 1;\n            var iBefore = i;\n            var fn = '';\n            while (true) {\n                ch = line[i];\n                if (ch === ' ' || ch === '\\t') {\n                    if(this.minorIndentFunctions.indexOf(fn) !== -1) {\n                        return this.$toIndent(line.substring(0, iBefore - 1) + tab);\n                    } else {\n                        return this.$toIndent(line.substring(0, i + 1));\n                    }\n                } else if (ch === undefined) {\n                    return this.$toIndent(line.substring(0, iBefore - 1) + tab);\n                }\n                fn += line[i];\n                i++;\n            }\n        } else if(delta < 0 && !isParen) {\n            return this.$toIndent(line.substring(0, i+1));\n        } else if(delta > 0) {\n            baseIndent = baseIndent.substring(0, baseIndent.length - tab.length);\n            return baseIndent;\n        } else {\n            return baseIndent;\n        }\n    };\n\n    this.getNextLineIndent = function(state, line, tab) {\n        return this.$calculateIndent(line, tab);\n    };\n\n    this.checkOutdent = function(state, line, input) {\n        return this.$outdent.checkOutdent(line, input);\n    };\n\n    this.autoOutdent = function(state, doc, row) {\n        this.$outdent.autoOutdent(doc, row);\n    };\n    \n    this.$id = \"ace/mode/scheme\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n});\n\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// vendor/brace/mode/scheme.js","ace.define(\"ace/mode/scheme_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text_highlight_rules\"], function(acequire, exports, module) {\n\"use strict\";\n\nvar oop = acequire(\"../lib/oop\");\nvar TextHighlightRules = acequire(\"./text_highlight_rules\").TextHighlightRules;\n\nvar SchemeHighlightRules = function() {\n    var keywordControl = \"case|do|let|loop|if|else|when\";\n    var keywordOperator = \"eq?|eqv?|equal?|and|or|not|null?\";\n    var constantLanguage = \"#t|#f\";\n    var supportFunctions = \"cons|car|cdr|cond|lambda|lambda*|syntax-rules|format|set!|quote|eval|append|list|list?|member?|load\";\n\n    var keywordMapper = this.createKeywordMapper({\n        \"keyword.control\": keywordControl,\n        \"keyword.operator\": keywordOperator,\n        \"constant.language\": constantLanguage,\n        \"support.function\": supportFunctions\n    }, \"identifier\", true);\n\n    this.$rules = \n        {\n    \"start\": [\n        {\n            token : \"comment\",\n            regex : \";.*$\"\n        },\n        {\n            \"token\": [\"storage.type.function-type.scheme\", \"text\", \"entity.name.function.scheme\"],\n            \"regex\": \"(?:\\\\b(?:(define|define-syntax|define-macro))\\\\b)(\\\\s+)((?:\\\\w|\\\\-|\\\\!|\\\\?)*)\"\n        },\n        {\n            \"token\": \"punctuation.definition.constant.character.scheme\",\n            \"regex\": \"#:\\\\S+\"\n        },\n        {\n            \"token\": [\"punctuation.definition.variable.scheme\", \"variable.other.global.scheme\", \"punctuation.definition.variable.scheme\"],\n            \"regex\": \"(\\\\*)(\\\\S*)(\\\\*)\"\n        },\n        {\n            \"token\" : \"constant.numeric\", // hex\n            \"regex\" : \"#[xXoObB][0-9a-fA-F]+\"\n        }, \n        {\n            \"token\" : \"constant.numeric\", // float\n            \"regex\" : \"[+-]?\\\\d+(?:(?:\\\\.\\\\d*)?(?:[eE][+-]?\\\\d+)?)?\"\n        },\n        {\n                \"token\" : keywordMapper,\n                \"regex\" : \"[a-zA-Z_#][a-zA-Z0-9_\\\\-\\\\?\\\\!\\\\*]*\"\n        },\n        {\n            \"token\" : \"string\",\n            \"regex\" : '\"(?=.)',\n            \"next\"  : \"qqstring\"\n        }\n    ],\n    \"qqstring\": [\n        {\n            \"token\": \"constant.character.escape.scheme\",\n            \"regex\": \"\\\\\\\\.\"\n        },\n        {\n            \"token\" : \"string\",\n            \"regex\" : '[^\"\\\\\\\\]+',\n            \"merge\" : true\n        }, {\n            \"token\" : \"string\",\n            \"regex\" : \"\\\\\\\\$\",\n            \"next\"  : \"qqstring\",\n            \"merge\" : true\n        }, {\n            \"token\" : \"string\",\n            \"regex\" : '\"|$',\n            \"next\"  : \"start\",\n            \"merge\" : true\n        }\n    ]\n}\n\n};\n\noop.inherits(SchemeHighlightRules, TextHighlightRules);\n\nexports.SchemeHighlightRules = SchemeHighlightRules;\n});\n\nace.define(\"ace/mode/matching_parens_outdent\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(acequire, exports, module) {\n\"use strict\";\n\nvar Range = acequire(\"../range\").Range;\n\nvar MatchingParensOutdent = function() {};\n\n(function() {\n\n    this.checkOutdent = function(line, input) {\n        if (! /^\\s+$/.test(line))\n            return false;\n\n        return /^\\s*\\)/.test(input);\n    };\n\n    this.autoOutdent = function(doc, row) {\n        var line = doc.getLine(row);\n        var match = line.match(/^(\\s*\\))/);\n\n        if (!match) return 0;\n\n        var column = match[1].length;\n        var openBracePos = doc.findMatchingBracket({row: row, column: column});\n\n        if (!openBracePos || openBracePos.row == row) return 0;\n\n        var indent = this.$getIndent(doc.getLine(openBracePos.row));\n        doc.replace(new Range(row, 0, row, column-1), indent);\n    };\n\n    this.$getIndent = function(line) {\n        var match = line.match(/^(\\s+)/);\n        if (match) {\n            return match[1];\n        }\n\n        return \"\";\n    };\n\n}).call(MatchingParensOutdent.prototype);\n\nexports.MatchingParensOutdent = MatchingParensOutdent;\n});\n\nace.define(\"ace/mode/scheme\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text\",\"ace/mode/scheme_highlight_rules\",\"ace/mode/matching_parens_outdent\"], function(acequire, exports, module) {\n\"use strict\";\n\nvar oop = acequire(\"../lib/oop\");\nvar TextMode = acequire(\"./text\").Mode;\nvar SchemeHighlightRules = acequire(\"./scheme_highlight_rules\").SchemeHighlightRules;\nvar MatchingParensOutdent = acequire(\"./matching_parens_outdent\").MatchingParensOutdent;\n\nvar Mode = function() {\n    this.HighlightRules = SchemeHighlightRules;\n\tthis.$outdent = new MatchingParensOutdent();\n    this.$behaviour = this.$defaultBehaviour;\n};\noop.inherits(Mode, TextMode);\n\n(function() {\n       \n    this.lineCommentStart = \";\";\n    this.minorIndentFunctions = [\"define\", \"lambda\", \"define-macro\", \"define-syntax\", \"syntax-rules\", \"define-record-type\", \"define-structure\"];\n\n    this.$toIndent = function(str) {\n        return str.split('').map(function(ch) {\n            if (/\\s/.exec(ch)) {\n                return ch;\n            } else {\n                return ' ';\n            }\n        }).join('');\n    };\n\n    this.$calculateIndent = function(line, tab) {\n        var baseIndent = this.$getIndent(line);\n        var delta = 0;\n        var isParen, ch;\n        for (var i = line.length - 1; i >= 0; i--) {\n            ch = line[i];\n            if (ch === '(') {\n                delta--;\n                isParen = true;\n            } else if (ch === '(' || ch === '[' || ch === '{') {\n                delta--;\n                isParen = false;\n            } else if (ch === ')' || ch === ']' || ch === '}') {\n                delta++;\n            }\n            if (delta < 0) {\n                break;\n            }\n        }\n        if (delta < 0 && isParen) {\n            i += 1;\n            var iBefore = i;\n            var fn = '';\n            while (true) {\n                ch = line[i];\n                if (ch === ' ' || ch === '\\t') {\n                    if(this.minorIndentFunctions.indexOf(fn) !== -1) {\n                        return this.$toIndent(line.substring(0, iBefore - 1) + tab);\n                    } else {\n                        return this.$toIndent(line.substring(0, i + 1));\n                    }\n                } else if (ch === undefined) {\n                    return this.$toIndent(line.substring(0, iBefore - 1) + tab);\n                }\n                fn += line[i];\n                i++;\n            }\n        } else if(delta < 0 && !isParen) {\n            return this.$toIndent(line.substring(0, i+1));\n        } else if(delta > 0) {\n            baseIndent = baseIndent.substring(0, baseIndent.length - tab.length);\n            return baseIndent;\n        } else {\n            return baseIndent;\n        }\n    };\n\n    this.getNextLineIndent = function(state, line, tab) {\n        return this.$calculateIndent(line, tab);\n    };\n\n    this.checkOutdent = function(state, line, input) {\n        return this.$outdent.checkOutdent(line, input);\n    };\n\n    this.autoOutdent = function(state, doc, row) {\n        this.$outdent.autoOutdent(doc, row);\n    };\n    \n    this.$id = \"ace/mode/scheme\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../node_modules/brace/mode/scheme.js\n// module id = 126\n// module chunks = 86"],"sourceRoot":""}