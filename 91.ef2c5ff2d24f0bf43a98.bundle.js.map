{"version":3,"file":"91.ef2c5ff2d24f0bf43a98.bundle.js","sources":["webpack:///./fields/code/node_modules/brace/mode/latex.js"],"sourcesContent":["ace.define(\"ace/mode/latex_highlight_rules\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text_highlight_rules\"], function (acequire, exports, module) {\n  \"use strict\";\n\n  var oop = acequire(\"../lib/oop\");\n  var TextHighlightRules = acequire(\"./text_highlight_rules\").TextHighlightRules;\n\n  var LatexHighlightRules = function LatexHighlightRules() {\n    this.$rules = {\n      \"start\": [{\n        token: \"comment\",\n        regex: \"%.*$\"\n      }, {\n        token: [\"keyword\", \"lparen\", \"variable.parameter\", \"rparen\", \"lparen\", \"storage.type\", \"rparen\"],\n        regex: \"(\\\\\\\\(?:documentclass|usepackage|input))(?:(\\\\[)([^\\\\]]*)(\\\\]))?({)([^}]*)(})\"\n      }, {\n        token: [\"keyword\", \"lparen\", \"variable.parameter\", \"rparen\"],\n        regex: \"(\\\\\\\\(?:label|v?ref|cite(?:[^{]*)))(?:({)([^}]*)(}))?\"\n      }, {\n        token: [\"storage.type\", \"lparen\", \"variable.parameter\", \"rparen\"],\n        regex: \"(\\\\\\\\(?:begin|end))({)(\\\\w*)(})\"\n      }, {\n        token: \"storage.type\",\n        regex: \"\\\\\\\\[a-zA-Z]+\"\n      }, {\n        token: \"lparen\",\n        regex: \"[[({]\"\n      }, {\n        token: \"rparen\",\n        regex: \"[\\\\])}]\"\n      }, {\n        token: \"constant.character.escape\",\n        regex: \"\\\\\\\\[^a-zA-Z]?\"\n      }, {\n        token: \"string\",\n        regex: \"\\\\${1,2}\",\n        next: \"equation\"\n      }],\n      \"equation\": [{\n        token: \"comment\",\n        regex: \"%.*$\"\n      }, {\n        token: \"string\",\n        regex: \"\\\\${1,2}\",\n        next: \"start\"\n      }, {\n        token: \"constant.character.escape\",\n        regex: \"\\\\\\\\(?:[^a-zA-Z]|[a-zA-Z]+)\"\n      }, {\n        token: \"error\",\n        regex: \"^\\\\s*$\",\n        next: \"start\"\n      }, {\n        defaultToken: \"string\"\n      }]\n    };\n  };\n\n  oop.inherits(LatexHighlightRules, TextHighlightRules);\n  exports.LatexHighlightRules = LatexHighlightRules;\n});\nace.define(\"ace/mode/folding/latex\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/folding/fold_mode\", \"ace/range\", \"ace/token_iterator\"], function (acequire, exports, module) {\n  \"use strict\";\n\n  var oop = acequire(\"../../lib/oop\");\n  var BaseFoldMode = acequire(\"./fold_mode\").FoldMode;\n  var Range = acequire(\"../../range\").Range;\n  var TokenIterator = acequire(\"../../token_iterator\").TokenIterator;\n\n  var FoldMode = exports.FoldMode = function () {};\n\n  oop.inherits(FoldMode, BaseFoldMode);\n  (function () {\n    this.foldingStartMarker = /^\\s*\\\\(begin)|(section|subsection|paragraph)\\b|{\\s*$/;\n    this.foldingStopMarker = /^\\s*\\\\(end)\\b|^\\s*}/;\n\n    this.getFoldWidgetRange = function (session, foldStyle, row) {\n      var line = session.doc.getLine(row);\n      var match = this.foldingStartMarker.exec(line);\n\n      if (match) {\n        if (match[1]) return this.latexBlock(session, row, match[0].length - 1);\n        if (match[2]) return this.latexSection(session, row, match[0].length - 1);\n        return this.openingBracketBlock(session, \"{\", row, match.index);\n      }\n\n      var match = this.foldingStopMarker.exec(line);\n\n      if (match) {\n        if (match[1]) return this.latexBlock(session, row, match[0].length - 1);\n        return this.closingBracketBlock(session, \"}\", row, match.index + match[0].length);\n      }\n    };\n\n    this.latexBlock = function (session, row, column) {\n      var keywords = {\n        \"\\\\begin\": 1,\n        \"\\\\end\": -1\n      };\n      var stream = new TokenIterator(session, row, column);\n      var token = stream.getCurrentToken();\n      if (!token || !(token.type == \"storage.type\" || token.type == \"constant.character.escape\")) return;\n      var val = token.value;\n      var dir = keywords[val];\n\n      var getType = function getType() {\n        var token = stream.stepForward();\n        var type = token.type == \"lparen\" ? stream.stepForward().value : \"\";\n\n        if (dir === -1) {\n          stream.stepBackward();\n          if (type) stream.stepBackward();\n        }\n\n        return type;\n      };\n\n      var stack = [getType()];\n      var startColumn = dir === -1 ? stream.getCurrentTokenColumn() : session.getLine(row).length;\n      var startRow = row;\n      stream.step = dir === -1 ? stream.stepBackward : stream.stepForward;\n\n      while (token = stream.step()) {\n        if (!token || !(token.type == \"storage.type\" || token.type == \"constant.character.escape\")) continue;\n        var level = keywords[token.value];\n        if (!level) continue;\n        var type = getType();\n        if (level === dir) stack.unshift(type);else if (stack.shift() !== type || !stack.length) break;\n      }\n\n      if (stack.length) return;\n      var row = stream.getCurrentTokenRow();\n      if (dir === -1) return new Range(row, session.getLine(row).length, startRow, startColumn);\n      stream.stepBackward();\n      return new Range(startRow, startColumn, row, stream.getCurrentTokenColumn());\n    };\n\n    this.latexSection = function (session, row, column) {\n      var keywords = [\"\\\\subsection\", \"\\\\section\", \"\\\\begin\", \"\\\\end\", \"\\\\paragraph\"];\n      var stream = new TokenIterator(session, row, column);\n      var token = stream.getCurrentToken();\n      if (!token || token.type != \"storage.type\") return;\n      var startLevel = keywords.indexOf(token.value);\n      var stackDepth = 0;\n      var endRow = row;\n\n      while (token = stream.stepForward()) {\n        if (token.type !== \"storage.type\") continue;\n        var level = keywords.indexOf(token.value);\n\n        if (level >= 2) {\n          if (!stackDepth) endRow = stream.getCurrentTokenRow() - 1;\n          stackDepth += level == 2 ? 1 : -1;\n          if (stackDepth < 0) break;\n        } else if (level >= startLevel) break;\n      }\n\n      if (!stackDepth) endRow = stream.getCurrentTokenRow() - 1;\n\n      while (endRow > row && !/\\S/.test(session.getLine(endRow))) {\n        endRow--;\n      }\n\n      return new Range(row, session.getLine(row).length, endRow, session.getLine(endRow).length);\n    };\n  }).call(FoldMode.prototype);\n});\nace.define(\"ace/mode/latex\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text\", \"ace/mode/latex_highlight_rules\", \"ace/mode/folding/latex\"], function (acequire, exports, module) {\n  \"use strict\";\n\n  var oop = acequire(\"../lib/oop\");\n  var TextMode = acequire(\"./text\").Mode;\n  var LatexHighlightRules = acequire(\"./latex_highlight_rules\").LatexHighlightRules;\n  var LatexFoldMode = acequire(\"./folding/latex\").FoldMode;\n\n  var Mode = function Mode() {\n    this.HighlightRules = LatexHighlightRules;\n    this.foldingRules = new LatexFoldMode();\n    this.$behaviour = this.$defaultBehaviour;\n  };\n\n  oop.inherits(Mode, TextMode);\n  (function () {\n    this.type = \"text\";\n    this.lineCommentStart = \"%\";\n    this.$id = \"ace/mode/latex\";\n  }).call(Mode.prototype);\n  exports.Mode = Mode;\n});"],"mappings":"AAAA","sourceRoot":""}