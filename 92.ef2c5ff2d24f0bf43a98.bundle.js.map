{"version":3,"file":"92.ef2c5ff2d24f0bf43a98.bundle.js","sources":["webpack:///./fields/code/node_modules/brace/mode/lean.js"],"sourcesContent":["ace.define(\"ace/mode/doc_comment_highlight_rules\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text_highlight_rules\"], function (acequire, exports, module) {\n  \"use strict\";\n\n  var oop = acequire(\"../lib/oop\");\n  var TextHighlightRules = acequire(\"./text_highlight_rules\").TextHighlightRules;\n\n  var DocCommentHighlightRules = function DocCommentHighlightRules() {\n    this.$rules = {\n      \"start\": [{\n        token: \"comment.doc.tag\",\n        regex: \"@[\\\\w\\\\d_]+\" // TODO: fix email addresses\n\n      }, DocCommentHighlightRules.getTagRule(), {\n        defaultToken: \"comment.doc\",\n        caseInsensitive: true\n      }]\n    };\n  };\n\n  oop.inherits(DocCommentHighlightRules, TextHighlightRules);\n\n  DocCommentHighlightRules.getTagRule = function (start) {\n    return {\n      token: \"comment.doc.tag.storage.type\",\n      regex: \"\\\\b(?:TODO|FIXME|XXX|HACK)\\\\b\"\n    };\n  };\n\n  DocCommentHighlightRules.getStartRule = function (start) {\n    return {\n      token: \"comment.doc\",\n      // doc comment\n      regex: \"\\\\/\\\\*(?=\\\\*)\",\n      next: start\n    };\n  };\n\n  DocCommentHighlightRules.getEndRule = function (start) {\n    return {\n      token: \"comment.doc\",\n      // closing comment\n      regex: \"\\\\*\\\\/\",\n      next: start\n    };\n  };\n\n  exports.DocCommentHighlightRules = DocCommentHighlightRules;\n});\nace.define(\"ace/mode/lean_highlight_rules\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/doc_comment_highlight_rules\", \"ace/mode/text_highlight_rules\"], function (acequire, exports, module) {\n  \"use strict\";\n\n  var oop = acequire(\"../lib/oop\");\n  var DocCommentHighlightRules = acequire(\"./doc_comment_highlight_rules\").DocCommentHighlightRules;\n  var TextHighlightRules = acequire(\"./text_highlight_rules\").TextHighlightRules;\n\n  var leanHighlightRules = function leanHighlightRules() {\n    var keywordControls = [\"add_rewrite\", \"alias\", \"as\", \"assume\", \"attribute\", \"begin\", \"by\", \"calc\", \"calc_refl\", \"calc_subst\", \"calc_trans\", \"check\", \"classes\", \"coercions\", \"conjecture\", \"constants\", \"context\", \"corollary\", \"else\", \"end\", \"environment\", \"eval\", \"example\", \"exists\", \"exit\", \"export\", \"exposing\", \"extends\", \"fields\", \"find_decl\", \"forall\", \"from\", \"fun\", \"have\", \"help\", \"hiding\", \"if\", \"import\", \"in\", \"infix\", \"infixl\", \"infixr\", \"instances\", \"let\", \"local\", \"match\", \"namespace\", \"notation\", \"obtain\", \"obtains\", \"omit\", \"opaque\", \"open\", \"options\", \"parameter\", \"parameters\", \"postfix\", \"precedence\", \"prefix\", \"premise\", \"premises\", \"print\", \"private\", \"proof\", \"protected\", \"qed\", \"raw\", \"renaming\", \"section\", \"set_option\", \"show\", \"tactic_hint\", \"take\", \"then\", \"universe\", \"universes\", \"using\", \"variable\", \"variables\", \"with\"].join(\"|\");\n    var nameProviders = [\"inductive\", \"structure\", \"record\", \"theorem\", \"axiom\", \"axioms\", \"lemma\", \"hypothesis\", \"definition\", \"constant\"].join(\"|\");\n    var storageType = [\"Prop\", \"Type\", \"Type'\", \"Type₊\", \"Type₁\", \"Type₂\", \"Type₃\"].join(\"|\");\n    var storageModifiers = \"\\\\[(\" + [\"abbreviations\", \"all-transparent\", \"begin-end-hints\", \"class\", \"classes\", \"coercion\", \"coercions\", \"declarations\", \"decls\", \"instance\", \"irreducible\", \"multiple-instances\", \"notation\", \"notations\", \"parsing-only\", \"persistent\", \"reduce-hints\", \"reducible\", \"tactic-hints\", \"visible\", \"wf\", \"whnf\"].join(\"|\") + \")\\\\]\";\n    var keywordOperators = [].join(\"|\");\n    var keywordMapper = this.$keywords = this.createKeywordMapper({\n      \"keyword.control\": keywordControls,\n      \"storage.type\": storageType,\n      \"keyword.operator\": keywordOperators,\n      \"variable.language\": \"sorry\"\n    }, \"identifier\");\n    var identifierRe = \"[A-Za-z_\\u03B1-\\u03BA\\u03BC-\\u03FB\\u1F00-\\u1FFE\\u2100-\\u214F][A-Za-z0-9_'\\u03B1-\\u03BA\\u03BC-\\u03FB\\u1F00-\\u1FFE\\u2070-\\u2079\\u207F-\\u2089\\u2090-\\u209C\\u2100-\\u214F]*\";\n    var operatorRe = new RegExp([\"#\", \"@\", \"->\", \"∼\", \"↔\", \"/\", \"==\", \"=\", \":=\", \"<->\", \"/\\\\\", \"\\\\/\", \"∧\", \"∨\", \"≠\", \"<\", \">\", \"≤\", \"≥\", \"¬\", \"<=\", \">=\", \"⁻¹\", \"⬝\", \"▸\", \"\\\\+\", \"\\\\*\", \"-\", \"/\", \"λ\", \"→\", \"∃\", \"∀\", \":=\"].join(\"|\"));\n    this.$rules = {\n      \"start\": [{\n        token: \"comment\",\n        // single line comment \"--\"\n        regex: \"--.*$\"\n      }, DocCommentHighlightRules.getStartRule(\"doc-start\"), {\n        token: \"comment\",\n        // multi line comment \"/-\"\n        regex: \"\\\\/-\",\n        next: \"comment\"\n      }, {\n        stateName: \"qqstring\",\n        token: \"string.start\",\n        regex: '\"',\n        next: [{\n          token: \"string.end\",\n          regex: '\"',\n          next: \"start\"\n        }, {\n          token: \"constant.language.escape\",\n          regex: /\\\\[n\"\\\\]/\n        }, {\n          defaultToken: \"string\"\n        }]\n      }, {\n        token: \"keyword.control\",\n        regex: nameProviders,\n        next: [{\n          token: \"variable.language\",\n          regex: identifierRe,\n          next: \"start\"\n        }]\n      }, {\n        token: \"constant.numeric\",\n        // hex\n        regex: \"0[xX][0-9a-fA-F]+(L|l|UL|ul|u|U|F|f|ll|LL|ull|ULL)?\\\\b\"\n      }, {\n        token: \"constant.numeric\",\n        // float\n        regex: \"[+-]?\\\\d+(?:(?:\\\\.\\\\d*)?(?:[eE][+-]?\\\\d+)?)?(L|l|UL|ul|u|U|F|f|ll|LL|ull|ULL)?\\\\b\"\n      }, {\n        token: \"storage.modifier\",\n        regex: storageModifiers\n      }, {\n        token: keywordMapper,\n        regex: identifierRe\n      }, {\n        token: \"operator\",\n        regex: operatorRe\n      }, {\n        token: \"punctuation.operator\",\n        regex: \"\\\\?|\\\\:|\\\\,|\\\\;|\\\\.\"\n      }, {\n        token: \"paren.lparen\",\n        regex: \"[[({]\"\n      }, {\n        token: \"paren.rparen\",\n        regex: \"[\\\\])}]\"\n      }, {\n        token: \"text\",\n        regex: \"\\\\s+\"\n      }],\n      \"comment\": [{\n        token: \"comment\",\n        regex: \"-/\",\n        next: \"start\"\n      }, {\n        defaultToken: \"comment\"\n      }]\n    };\n    this.embedRules(DocCommentHighlightRules, \"doc-\", [DocCommentHighlightRules.getEndRule(\"start\")]);\n    this.normalizeRules();\n  };\n\n  oop.inherits(leanHighlightRules, TextHighlightRules);\n  exports.leanHighlightRules = leanHighlightRules;\n});\nace.define(\"ace/mode/matching_brace_outdent\", [\"require\", \"exports\", \"module\", \"ace/range\"], function (acequire, exports, module) {\n  \"use strict\";\n\n  var Range = acequire(\"../range\").Range;\n\n  var MatchingBraceOutdent = function MatchingBraceOutdent() {};\n\n  (function () {\n    this.checkOutdent = function (line, input) {\n      if (!/^\\s+$/.test(line)) return false;\n      return /^\\s*\\}/.test(input);\n    };\n\n    this.autoOutdent = function (doc, row) {\n      var line = doc.getLine(row);\n      var match = line.match(/^(\\s*\\})/);\n      if (!match) return 0;\n      var column = match[1].length;\n      var openBracePos = doc.findMatchingBracket({\n        row: row,\n        column: column\n      });\n      if (!openBracePos || openBracePos.row == row) return 0;\n      var indent = this.$getIndent(doc.getLine(openBracePos.row));\n      doc.replace(new Range(row, 0, row, column - 1), indent);\n    };\n\n    this.$getIndent = function (line) {\n      return line.match(/^\\s*/)[0];\n    };\n  }).call(MatchingBraceOutdent.prototype);\n  exports.MatchingBraceOutdent = MatchingBraceOutdent;\n});\nace.define(\"ace/mode/lean\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text\", \"ace/mode/lean_highlight_rules\", \"ace/mode/matching_brace_outdent\", \"ace/range\"], function (acequire, exports, module) {\n  \"use strict\";\n\n  var oop = acequire(\"../lib/oop\");\n  var TextMode = acequire(\"./text\").Mode;\n  var leanHighlightRules = acequire(\"./lean_highlight_rules\").leanHighlightRules;\n  var MatchingBraceOutdent = acequire(\"./matching_brace_outdent\").MatchingBraceOutdent;\n  var Range = acequire(\"../range\").Range;\n\n  var Mode = function Mode() {\n    this.HighlightRules = leanHighlightRules;\n    this.$outdent = new MatchingBraceOutdent();\n  };\n\n  oop.inherits(Mode, TextMode);\n  (function () {\n    this.lineCommentStart = \"--\";\n    this.blockComment = {\n      start: \"/-\",\n      end: \"-/\"\n    };\n\n    this.getNextLineIndent = function (state, line, tab) {\n      var indent = this.$getIndent(line);\n      var tokenizedLine = this.getTokenizer().getLineTokens(line, state);\n      var tokens = tokenizedLine.tokens;\n      var endState = tokenizedLine.state;\n\n      if (tokens.length && tokens[tokens.length - 1].type == \"comment\") {\n        return indent;\n      }\n\n      if (state == \"start\") {\n        var match = line.match(/^.*[\\{\\(\\[]\\s*$/);\n\n        if (match) {\n          indent += tab;\n        }\n      } else if (state == \"doc-start\") {\n        if (endState == \"start\") {\n          return \"\";\n        }\n\n        var match = line.match(/^\\s*(\\/?)\\*/);\n\n        if (match) {\n          if (match[1]) {\n            indent += \" \";\n          }\n\n          indent += \"- \";\n        }\n      }\n\n      return indent;\n    };\n\n    this.checkOutdent = function (state, line, input) {\n      return this.$outdent.checkOutdent(line, input);\n    };\n\n    this.autoOutdent = function (state, doc, row) {\n      this.$outdent.autoOutdent(doc, row);\n    };\n\n    this.$id = \"ace/mode/lean\";\n  }).call(Mode.prototype);\n  exports.Mode = Mode;\n});"],"mappings":"AAAA","sourceRoot":""}