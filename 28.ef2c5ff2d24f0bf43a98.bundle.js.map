{"version":3,"file":"28.ef2c5ff2d24f0bf43a98.bundle.js","sources":["webpack:///./fields/code/node_modules/brace/ext/whitespace.js"],"sourcesContent":["ace.define(\"ace/ext/whitespace\", [\"require\", \"exports\", \"module\", \"ace/lib/lang\"], function (acequire, exports, module) {\n  \"use strict\";\n\n  var lang = acequire(\"../lib/lang\");\n\n  exports.$detectIndentation = function (lines, fallback) {\n    var stats = [];\n    var changes = [];\n    var tabIndents = 0;\n    var prevSpaces = 0;\n    var max = Math.min(lines.length, 1000);\n\n    for (var i = 0; i < max; i++) {\n      var line = lines[i];\n      if (!/^\\s*[^*+\\-\\s]/.test(line)) continue;\n\n      if (line[0] == \"\\t\") {\n        tabIndents++;\n        prevSpaces = -Number.MAX_VALUE;\n      } else {\n        var spaces = line.match(/^ */)[0].length;\n\n        if (spaces && line[spaces] != \"\\t\") {\n          var diff = spaces - prevSpaces;\n          if (diff > 0 && !(prevSpaces % diff) && !(spaces % diff)) changes[diff] = (changes[diff] || 0) + 1;\n          stats[spaces] = (stats[spaces] || 0) + 1;\n        }\n\n        prevSpaces = spaces;\n      }\n\n      while (i < max && line[line.length - 1] == \"\\\\\") {\n        line = lines[i++];\n      }\n    }\n\n    function getScore(indent) {\n      var score = 0;\n\n      for (var i = indent; i < stats.length; i += indent) {\n        score += stats[i] || 0;\n      }\n\n      return score;\n    }\n\n    var changesTotal = changes.reduce(function (a, b) {\n      return a + b;\n    }, 0);\n    var first = {\n      score: 0,\n      length: 0\n    };\n    var spaceIndents = 0;\n\n    for (var i = 1; i < 12; i++) {\n      var score = getScore(i);\n\n      if (i == 1) {\n        spaceIndents = score;\n        score = stats[1] ? 0.9 : 0.8;\n        if (!stats.length) score = 0;\n      } else score /= spaceIndents;\n\n      if (changes[i]) score += changes[i] / changesTotal;\n      if (score > first.score) first = {\n        score: score,\n        length: i\n      };\n    }\n\n    if (first.score && first.score > 1.4) var tabLength = first.length;\n\n    if (tabIndents > spaceIndents + 1) {\n      if (tabLength == 1 || spaceIndents < tabIndents / 4 || first.score < 1.8) tabLength = undefined;\n      return {\n        ch: \"\\t\",\n        length: tabLength\n      };\n    }\n\n    if (spaceIndents > tabIndents + 1) return {\n      ch: \" \",\n      length: tabLength\n    };\n  };\n\n  exports.detectIndentation = function (session) {\n    var lines = session.getLines(0, 1000);\n    var indent = exports.$detectIndentation(lines) || {};\n    if (indent.ch) session.setUseSoftTabs(indent.ch == \" \");\n    if (indent.length) session.setTabSize(indent.length);\n    return indent;\n  };\n\n  exports.trimTrailingSpace = function (session, trimEmpty) {\n    var doc = session.getDocument();\n    var lines = doc.getAllLines();\n    var min = trimEmpty ? -1 : 0;\n\n    for (var i = 0, l = lines.length; i < l; i++) {\n      var line = lines[i];\n      var index = line.search(/\\s+$/);\n      if (index > min) doc.removeInLine(i, index, line.length);\n    }\n  };\n\n  exports.convertIndentation = function (session, ch, len) {\n    var oldCh = session.getTabString()[0];\n    var oldLen = session.getTabSize();\n    if (!len) len = oldLen;\n    if (!ch) ch = oldCh;\n    var tab = ch == \"\\t\" ? ch : lang.stringRepeat(ch, len);\n    var doc = session.doc;\n    var lines = doc.getAllLines();\n    var cache = {};\n    var spaceCache = {};\n\n    for (var i = 0, l = lines.length; i < l; i++) {\n      var line = lines[i];\n      var match = line.match(/^\\s*/)[0];\n\n      if (match) {\n        var w = session.$getStringScreenWidth(match)[0];\n        var tabCount = Math.floor(w / oldLen);\n        var reminder = w % oldLen;\n        var toInsert = cache[tabCount] || (cache[tabCount] = lang.stringRepeat(tab, tabCount));\n        toInsert += spaceCache[reminder] || (spaceCache[reminder] = lang.stringRepeat(\" \", reminder));\n\n        if (toInsert != match) {\n          doc.removeInLine(i, 0, match.length);\n          doc.insertInLine({\n            row: i,\n            column: 0\n          }, toInsert);\n        }\n      }\n    }\n\n    session.setTabSize(len);\n    session.setUseSoftTabs(ch == \" \");\n  };\n\n  exports.$parseStringArg = function (text) {\n    var indent = {};\n    if (/t/.test(text)) indent.ch = \"\\t\";else if (/s/.test(text)) indent.ch = \" \";\n    var m = text.match(/\\d+/);\n    if (m) indent.length = parseInt(m[0], 10);\n    return indent;\n  };\n\n  exports.$parseArg = function (arg) {\n    if (!arg) return {};\n    if (typeof arg == \"string\") return exports.$parseStringArg(arg);\n    if (typeof arg.text == \"string\") return exports.$parseStringArg(arg.text);\n    return arg;\n  };\n\n  exports.commands = [{\n    name: \"detectIndentation\",\n    exec: function exec(editor) {\n      exports.detectIndentation(editor.session);\n    }\n  }, {\n    name: \"trimTrailingSpace\",\n    exec: function exec(editor) {\n      exports.trimTrailingSpace(editor.session);\n    }\n  }, {\n    name: \"convertIndentation\",\n    exec: function exec(editor, arg) {\n      var indent = exports.$parseArg(arg);\n      exports.convertIndentation(editor.session, indent.ch, indent.length);\n    }\n  }, {\n    name: \"setIndentation\",\n    exec: function exec(editor, arg) {\n      var indent = exports.$parseArg(arg);\n      indent.length && editor.session.setTabSize(indent.length);\n      indent.ch && editor.session.setUseSoftTabs(indent.ch == \" \");\n    }\n  }];\n});\n\n(function () {\n  ace.acequire([\"ace/ext/whitespace\"], function () {});\n})();"],"mappings":"AAAA","sourceRoot":""}